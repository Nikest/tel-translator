<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI OPERATOR</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, sans-serif; }
        .hidden { display: none !important; }
        body {
            min-height: 100vh; display: flex; align-items: center; justify-content: center;
            background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%); color: #e5e7eb;
        }
        .call-card {
            background: rgba(15, 23, 42, 0.9); border-radius: 24px; padding: 32px; width: 320px;
            box-shadow: 0 18px 40px rgba(0,0,0,0.55), 0 0 0 1px rgba(148,163,184,0.15);
            text-align: center; position: relative; overflow: hidden;
            transition: all 0.3s ease;
        }
        .call-card::before {
            content: ""; position: absolute; inset: -40%;
            background: conic-gradient(from 220deg, rgba(34,197,94,0.32), rgba(239,68,68,0.32), transparent, transparent, rgba(56,189,248,0.26), transparent);
            opacity: 0.3; filter: blur(28px); z-index: -1;
        }
        .call-status { font-size: 0.9rem; letter-spacing: 0.14em; text-transform: uppercase; color: #9ca3af; margin-bottom: 10px; }
        .call-number { font-size: 1.4rem; font-weight: 600; color: #e5e7eb; margin-bottom: 4px; }
        .call-sub { font-size: 0.9rem; color: #9ca3af; margin-bottom: 24px; }
        .call-button {
            border: none; outline: none; cursor: pointer; padding: 14px 26px; font-size: 1rem; font-weight: 600;
            border-radius: 999px; display: inline-flex; align-items: center; justify-content: center; gap: 10px;
            letter-spacing: 0.04em; text-transform: uppercase; color: #f9fafb; width: 100%;
            transition: transform 0.12s, box-shadow 0.12s, filter 0.12s;
        }
        .call-button:hover { transform: translateY(-1px); filter: brightness(1.1); }
        .call-button:active { transform: translateY(1px); filter: brightness(0.95); }
        .call-button.answer { background: linear-gradient(135deg, #22c55e, #16a34a); box-shadow: 0 0 0 1px rgba(34,197,94,0.5); }
        .call-button.end { background: linear-gradient(135deg, #ef4444, #b91c1c); box-shadow: 0 0 0 1px rgba(248,113,113,0.5); }
        .call-button.wait { background: #334155; cursor: default; }
    </style>
</head>
<body>

<div id="connectContainer" class="call-card">
    <div class="call-status">System Offline</div>
    <div class="call-sub">Connect to operator network</div>
    <button id="btnConnect" class="call-button answer">
        <span>Connect to Server</span>
    </button>
</div>

<div id="operatorContainer" class="call-card hidden">
    <div id="statusText" class="call-status">Waiting...</div>
    <div id="callerNumber" class="call-number">---</div>
    <div id="callerSub" class="call-sub">Waiting for incoming call</div>

    <button id="btnWaiting" class="call-button wait">
        <span>Waiting for call...</span>
    </button>

    <button id="btnAnswer" class="call-button answer hidden">
        <span>üìû Answer Call</span>
    </button>

    <button id="btnEnd" class="call-button end hidden">
        <span>‚úï End Call</span>
    </button>
</div>

<script>
    // --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –¥–ª—è WebSocket (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ wss:// –µ—Å–ª–∏ https://)
    const PROTOCOL = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const WS_URL = `${PROTOCOL}//${window.location.host}/operator`;
    const SAMPLE_RATE = 24000; // OpenAI Realtime –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç 24kHz

    // --- –°–û–°–¢–û–Ø–ù–ò–ï ---
    let ws;
    let audioContext;
    let scriptProcessor;
    let mediaStream;
    let nextStartTime = 0; // –î–ª—è –ø–ª–∞–≤–Ω–æ–π –æ—á–µ—Ä–µ–¥–∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
    let isCallActive = false;

    // --- UI –≠–õ–ï–ú–ï–ù–¢–´ ---
    const connectContainer = document.getElementById('connectContainer');
    const operatorContainer = document.getElementById('operatorContainer');
    const statusText = document.getElementById('statusText');
    const callerNumber = document.getElementById('callerNumber');
    const callerSub = document.getElementById('callerSub');
    const btnConnect = document.getElementById('btnConnect');
    const btnWaiting = document.getElementById('btnWaiting');
    const btnAnswer = document.getElementById('btnAnswer');
    const btnEnd = document.getElementById('btnEnd');

    // --- 1. –ù–ê–ñ–ê–¢–ò–ï "CONNECT TO SERVER" ---
    btnConnect.addEventListener('click', () => {
        initWebSocket();
    });

    function initWebSocket() {
        ws = new WebSocket(WS_URL);

        ws.onopen = () => {
            console.log('Connected to server');
            // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º UI –Ω–∞ —ç–∫—Ä–∞–Ω –æ–∂–∏–¥–∞–Ω–∏—è
            connectContainer.classList.add('hidden');
            operatorContainer.classList.remove('hidden');
            statusText.innerText = "Online";
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–∞—Ç—É—Å–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
            if (data.type === 'status') {
                console.log('Status:', data.msg);

                if (data.msg === 'Call Connected!') {
                    // –ó–≤–æ–Ω–æ–∫ –ø—Ä–∏—à–µ–ª! –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –æ—Ç–≤–µ—Ç–∞
                    handleIncomingCall();
                } else if (data.msg === 'Waiting for a call...') {
                    resetCallUI();
                }
            }

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–µ–≥–æ –∞—É–¥–∏–æ (–æ—Ç –ê–±–æ–Ω–µ–Ω—Ç–∞)
            if (data.type === 'audio' && isCallActive) {
                playAudioChunk(data.payload);
            }
        };

        ws.onclose = () => {
            alert('Disconnected from server. Refresh to reconnect.');
            location.reload();
        };
    }

    // --- 2. –í–•–û–î–Ø–©–ò–ô –ó–í–û–ù–û–ö ---
    function handleIncomingCall() {
        statusText.innerText = "Incoming Call";
        callerNumber.innerText = "Unknown Caller";
        callerSub.innerText = "Russian Speaker";

        btnWaiting.classList.add('hidden');
        btnAnswer.classList.remove('hidden');

        // –í–ê–ñ–ù–û: –ë—Ä–∞—É–∑–µ—Ä –∑–∞–ø—Ä–µ—â–∞–µ—Ç –∏–≥—Ä–∞—Ç—å –∑–≤—É–∫ –±–µ–∑ –¥–µ–π—Å—Ç–≤–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
        // –ü–æ—ç—Ç–æ–º—É –º—ã –∂–¥–µ–º –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ "Answer" –¥–ª—è —Å—Ç–∞—Ä—Ç–∞ AudioContext.
    }

    // --- 3. –ù–ê–ñ–ê–¢–ò–ï "ANSWER" (–°–¢–ê–†–¢ –ê–£–î–ò–û) ---
    btnAnswer.addEventListener('click', async () => {
        try {
            await startAudioSystem();

            isCallActive = true;
            statusText.innerText = "In Call";
            statusText.style.color = "#22c55e"; // Green

            btnAnswer.classList.add('hidden');
            btnEnd.classList.remove('hidden');

        } catch (err) {
            console.error('Mic Access Error:', err);
            alert('Microphone access is required!');
        }
    });

    // --- 4. –ù–ê–ñ–ê–¢–ò–ï "END CALL" ---
    btnEnd.addEventListener('click', () => {
        // –ü—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è —Å–±—Ä–æ—Å–∞ (–ø—Ä–æ—Å—Ç–µ–π—à–∏–π —Å–ø–æ—Å–æ–±)
        location.reload();
    });

    // ==========================================
    // === –ê–£–î–ò–û –õ–û–ì–ò–ö–ê (–°–õ–û–ñ–ù–ê–Ø –ß–ê–°–¢–¨) ===
    // ==========================================

    async function startAudioSystem() {
        // 1. –°–æ–∑–¥–∞–µ–º AudioContext
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: SAMPLE_RATE
        });

        nextStartTime = audioContext.currentTime;

        // 2. –ó–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º –º–∏–∫—Ä–æ—Ñ–æ–Ω
        mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: {
                channelCount: 1,
                sampleRate: SAMPLE_RATE,
                echoCancellation: true,
                noiseSuppression: true
            }
        });

        const source = audioContext.createMediaStreamSource(mediaStream);

        // 3. –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –¥–ª—è –∑–∞—Ö–≤–∞—Ç–∞ raw PCM (deprecated, –Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤–µ–∑–¥–µ –¥–ª—è –ø—Ä–æ—Å—Ç—ã—Ö –∑–∞–¥–∞—á)
        // bufferSize 2048 –¥–∞–µ—Ç –±–∞–ª–∞–Ω—Å –º–µ–∂–¥—É –∑–∞–¥–µ—Ä–∂–∫–æ–π –∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å—é
        scriptProcessor = audioContext.createScriptProcessor(2048, 1, 1);

        source.connect(scriptProcessor);
        scriptProcessor.connect(audioContext.destination);

        // 4. –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Å –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞
        scriptProcessor.onaudioprocess = (e) => {
            if (!isCallActive || ws.readyState !== WebSocket.OPEN) return;

            const inputData = e.inputBuffer.getChannelData(0); // Float32 Array

            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Float32 –≤ Int16 (PCM)
            const pcm16 = floatTo16BitPCM(inputData);

            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ Base64 –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º
            const base64Audio = arrayBufferToBase64(pcm16);

            ws.send(JSON.stringify({
                type: 'audio',
                payload: base64Audio
            }));
        };
    }

    // --- –í–û–°–ü–†–û–ò–ó–í–ï–î–ï–ù–ò–ï –ê–£–î–ò–û (SERVER -> SPEAKER) ---
    function playAudioChunk(base64String) {
        if (!audioContext) return;

        // –î–µ–∫–æ–¥–∏—Ä—É–µ–º Base64 –≤ ArrayBuffer
        const arrayBuffer = base64ToArrayBuffer(base64String);
        const int16Array = new Int16Array(arrayBuffer);

        // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Int16 –æ–±—Ä–∞—Ç–Ω–æ –≤ Float32 –¥–ª—è –±—Ä–∞—É–∑–µ—Ä–∞
        const float32Array = new Float32Array(int16Array.length);
        for (let i = 0; i < int16Array.length; i++) {
            float32Array[i] = int16Array[i] / 32768.0;
        }

        // –°–æ–∑–¥–∞–µ–º –∞—É–¥–∏–æ-–±—É—Ñ–µ—Ä
        const audioBuffer = audioContext.createBuffer(1, float32Array.length, SAMPLE_RATE);
        audioBuffer.copyToChannel(float32Array, 0);

        // –ü–ª–∞–Ω–∏—Ä—É–µ–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –±–µ–∑ –Ω–∞–ª–æ–∂–µ–Ω–∏–π
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);

        const currentTime = audioContext.currentTime;
        // –ï—Å–ª–∏ –æ—á–µ—Ä–µ–¥—å –æ—Ç—Å—Ç–∞–ª–∞ –æ—Ç –≤—Ä–µ–º–µ–Ω–∏ (–ø–∞—É–∑–∞), —Å–±—Ä–∞—Å—ã–≤–∞–µ–º
        if (nextStartTime < currentTime) nextStartTime = currentTime;

        source.start(nextStartTime);
        // –°–¥–≤–∏–≥–∞–µ–º –≤—Ä–µ–º—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –∫—É—Å–∫–∞ –Ω–∞ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç–µ–∫—É—â–µ–≥–æ
        nextStartTime += audioBuffer.duration;
    }

    // --- –£–¢–ò–õ–ò–¢–´ (HELPER FUNCTIONS) ---

    // –ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä Float32 (Browser Mic) -> Int16 (Server)
    function floatTo16BitPCM(input) {
        const output = new Int16Array(input.length);
        for (let i = 0; i < input.length; i++) {
            let s = Math.max(-1, Math.min(1, input[i]));
            output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        return output.buffer;
    }

    // Base64 -> ArrayBuffer
    function base64ToArrayBuffer(base64) {
        const binaryString = window.atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    // ArrayBuffer -> Base64
    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }

</script>
</body>
</html>