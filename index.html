<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI OPERATOR</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, sans-serif; }
        .hidden { display: none !important; }
        body {
            min-height: 100vh; display: flex; align-items: center; justify-content: center;
            background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%); color: #e5e7eb;
        }
        .call-card {
            background: rgba(15, 23, 42, 0.9); border-radius: 24px; padding: 32px; width: 320px;
            box-shadow: 0 18px 40px rgba(0,0,0,0.55), 0 0 0 1px rgba(148,163,184,0.15);
            text-align: center; position: relative; overflow: hidden;
            transition: all 0.3s ease;
        }
        .call-status { font-size: 0.9rem; letter-spacing: 0.14em; text-transform: uppercase; color: #9ca3af; margin-bottom: 10px; }
        .call-number { font-size: 1.4rem; font-weight: 600; color: #e5e7eb; margin-bottom: 4px; }
        .call-sub { font-size: 0.9rem; color: #9ca3af; margin-bottom: 24px; }
        .call-button {
            border: none; outline: none; cursor: pointer; padding: 14px 26px; font-size: 1rem; font-weight: 600;
            border-radius: 999px; display: inline-flex; align-items: center; justify-content: center; gap: 10px;
            letter-spacing: 0.04em; text-transform: uppercase; color: #f9fafb; width: 100%;
            transition: transform 0.12s;
        }
        .call-button:hover { transform: translateY(-1px); filter: brightness(1.1); }
        .call-button:active { transform: translateY(1px); filter: brightness(0.95); }
        .call-button.answer { background: linear-gradient(135deg, #22c55e, #16a34a); box-shadow: 0 0 0 1px rgba(34,197,94,0.5); }
        .call-button.end { background: linear-gradient(135deg, #ef4444, #b91c1c); box-shadow: 0 0 0 1px rgba(248,113,113,0.5); }
        .call-button.wait { background: #334155; cursor: default; }
    </style>
</head>
<body>

<div id="connectContainer" class="call-card">
    <div class="call-status">System Offline</div>
    <div class="call-sub">Connect to operator network</div>
    <button id="btnConnect" class="call-button answer"><span>Connect to Server</span></button>
</div>

<div id="operatorContainer" class="call-card hidden">
    <div id="statusText" class="call-status">Waiting...</div>
    <div id="callerNumber" class="call-number">---</div>
    <div id="callerSub" class="call-sub">Waiting for incoming call</div>

    <button id="btnWaiting" class="call-button wait"><span>Waiting for call...</span></button>
    <button id="btnAnswer" class="call-button answer hidden"><span>ðŸ“ž Answer Call</span></button>
    <button id="btnEnd" class="call-button end hidden"><span>âœ• End Call</span></button>
</div>

<script>
    const PROTOCOL = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const WS_URL = `${PROTOCOL}//${window.location.host}/operator`;
    const SAMPLE_RATE = 24000;

    let ws;
    let audioContext;
    let scriptProcessor;
    let mediaStream;
    let nextStartTime = 0;
    let isCallActive = false;

    // UI Elements
    const connectContainer = document.getElementById('connectContainer');
    const operatorContainer = document.getElementById('operatorContainer');
    const statusText = document.getElementById('statusText');
    const callerNumber = document.getElementById('callerNumber');
    const callerSub = document.getElementById('callerSub');
    const btnConnect = document.getElementById('btnConnect');
    const btnWaiting = document.getElementById('btnWaiting');
    const btnAnswer = document.getElementById('btnAnswer');
    const btnEnd = document.getElementById('btnEnd');

    btnConnect.addEventListener('click', initWebSocket);

    function initWebSocket() {
        ws = new WebSocket(WS_URL);

        ws.onopen = () => {
            console.log('Connected to server');
            connectContainer.classList.add('hidden');
            operatorContainer.classList.remove('hidden');
            statusText.innerText = "Online";
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);

            if (data.type === 'status') {
                console.log('Status:', data.msg);
                if (data.msg === 'Call Connected!') handleIncomingCall();
                else if (data.msg === 'Waiting for a call...') resetCallUI();
            }

            if (data.type === 'audio' && isCallActive) {
                playAudioChunk(data.payload);
            }
        };

        ws.onclose = () => {
            console.log('WS Disconnected');
            statusText.innerText = "Offline";
        };
    }

    // --- Ð¤Ð£ÐÐšÐ¦Ð˜Ð¯, ÐšÐžÐ¢ÐžÐ ÐžÐ™ ÐÐ• Ð¥Ð’ÐÐ¢ÐÐ›Ðž ---
    function resetCallUI() {
        statusText.innerText = "Waiting...";
        statusText.style.color = "#9ca3af";
        callerNumber.innerText = "---";
        callerSub.innerText = "Waiting for incoming call";

        btnWaiting.classList.remove('hidden');
        btnAnswer.classList.add('hidden');
        btnEnd.classList.add('hidden');
        isCallActive = false;

        // Ð—Ð°ÐºÑ€Ñ‹Ð²Ð°ÐµÐ¼ Ð¼Ð¸ÐºÑ€Ð¾Ñ„Ð¾Ð½, ÐµÑÐ»Ð¸ Ð±Ñ‹Ð» Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚
        if (audioContext) audioContext.close();
        audioContext = null;
    }

    function handleIncomingCall() {
        statusText.innerText = "Incoming Call";
        callerNumber.innerText = "Aboment";
        callerSub.innerText = "Russian Speaker";
        btnWaiting.classList.add('hidden');
        btnAnswer.classList.remove('hidden');
    }

    btnAnswer.addEventListener('click', async () => {
        try {
            await startAudioSystem();
            isCallActive = true;
            statusText.innerText = "In Call";
            statusText.style.color = "#22c55e";
            btnAnswer.classList.add('hidden');
            btnEnd.classList.remove('hidden');
        } catch (err) {
            console.error('Mic Error:', err);
            alert('Microphone access denied!');
        }
    });

    btnEnd.addEventListener('click', () => {
        location.reload();
    });

    // --- AUDIO LOGIC ---
    async function startAudioSystem() {
        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });

        // Ð’ÐÐ–ÐÐž: Resume ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }

        nextStartTime = audioContext.currentTime;

        mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: { channelCount: 1, sampleRate: SAMPLE_RATE, echoCancellation: true, noiseSuppression: true }
        });

        const source = audioContext.createMediaStreamSource(mediaStream);
        scriptProcessor = audioContext.createScriptProcessor(2048, 1, 1);

        source.connect(scriptProcessor);
        scriptProcessor.connect(audioContext.destination);

        scriptProcessor.onaudioprocess = (e) => {
            if (!isCallActive || ws.readyState !== WebSocket.OPEN) return;
            const inputData = e.inputBuffer.getChannelData(0);
            const pcm16 = floatTo16BitPCM(inputData);
            const base64Audio = arrayBufferToBase64(pcm16);
            ws.send(JSON.stringify({ type: 'audio', payload: base64Audio }));
        };
    }

    function playAudioChunk(base64String) {
        if (!audioContext) return;
        const arrayBuffer = base64ToArrayBuffer(base64String);
        const int16Array = new Int16Array(arrayBuffer);
        const float32Array = new Float32Array(int16Array.length);
        for (let i = 0; i < int16Array.length; i++) {
            float32Array[i] = int16Array[i] / 32768.0;
        }
        const audioBuffer = audioContext.createBuffer(1, float32Array.length, SAMPLE_RATE);
        audioBuffer.copyToChannel(float32Array, 0);
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);

        const currentTime = audioContext.currentTime;
        if (nextStartTime < currentTime) nextStartTime = currentTime;
        source.start(nextStartTime);
        nextStartTime += audioBuffer.duration;
    }

    function floatTo16BitPCM(input) {
        const output = new Int16Array(input.length);
        for (let i = 0; i < input.length; i++) {
            let s = Math.max(-1, Math.min(1, input[i]));
            output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        return output.buffer;
    }

    function base64ToArrayBuffer(base64) {
        const binaryString = window.atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
        return bytes.buffer;
    }

    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) { binary += String.fromCharCode(bytes[i]); }
        return window.btoa(binary);
    }
</script>
</body>
</html>